<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&family=IBM+Plex+Sans+KR&family=Jua&display=swap" rel="stylesheet">

</head>

<style>
  body {
    margin: 0px;
    width: 100vw;
    height: 90vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: black;
    overflow: hidden;
    /*font-family: "IBM Plex Sans KR", sans-serif;
    font-weight: 400;
    font-style: normal;*/
  }

  #world {
    background : linear-gradient(135deg, #ACA1FF, #9283FF, #7F6EFD);
    border-radius: 10px;
    overflow: hidden;
    position: relative;
    width: 1200px;
    height: 600px;
    box-shadow: inset -10px -10px 10px #00000040,inset 5px 5px 10px #FFFFFF40;
  }

  .object {
    position: absolute;
  }

  #player{
    position: absolute;
    background-color: transparent;
    box-shadow: 5px 5px 3px #00000050;
    transition: all 0.15s ease-out;
    border-radius: 5px;
  }

  #player div{
    position: absolute;
    background: linear-gradient(135deg, #FDD8AA, #FFD07E, #FCBF57, #FFAB44, #FFAB44);
    transition: all 1s ease-out;
    border: none;
    border-radius: 5px;
    box-shadow: inset -2px -2px 2px #733F0080, inset -22px -22px 2px #FFFFFF50;
    width: 20px;
    height: 20px;
    animation: show 1s ease-in-out;
  }

  /*#player::after{
    content: '';
    position: absolute;
    top: -12px;
    left: -12px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255, 0, 0, 0.3);
    
  }*/
  .enemy {
    position: absolute;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 0px 7px 15px 7px;
    border-color: transparent transparent #E7E5FA transparent;
    animation: show 2s ease-in-out;
    /*box-shadow: 0px 0px 1px #000000;*/
  }

  @keyframes show{
    0%{opacity: 0;}
    100%{opacity: 1;}
  }

  @keyframes scoreSet{
    50%{transform: scale(1.2) translateY(-5px);}
    100%{}
  }

  #score {
    margin: 8px 12px;
    color: white;
    font-size: 40px;
    font-weight: bold;
    transition: all 0.5s ease;
    position: absolute; 
  }
</style>

<div id="world">
  <div id = "player_range">
    <div id="player"><div id="player-dis"></div></div>
  </div>
  <div id = "score" class="object" style = "z-index: 1;">#10</div>
</div>

<script>
  // 시스템 함수 설정
  function HTML(name) {
    return document.querySelector(name);
  }

  // 게임 함수 설정
  const 설정객체 = {
    주인공크기: { x: 20, y: 20 },
    월드크기: { x: 1200, y: 600 }
  };
  const keyIntervals = {};
  const 오브젝트 = {};
  let 충돌중복방지 = true;

  function 기본설정() {
    const 주인공 = HTML('#player');
    const 월드 = HTML('#world');
    
    월드.style.minWidth = `${설정객체.월드크기.x}px`;
    월드.style.minHeight = `${설정객체.월드크기.y}px`;

    주인공.style.width = `${설정객체.주인공크기.x}px`;
    주인공.style.height = `${설정객체.주인공크기.y}px`;
    주인공.style.top = `${월드.getBoundingClientRect().height / 2 - 설정객체.주인공크기.y / 2}px`;
    주인공.style.left = `${월드.getBoundingClientRect().width / 2 - 설정객체.주인공크기.x / 2}px`;

    // 주인공 오브젝트 추가
    오브젝트['#player'] = {
      name: '#player',
      x: parseInt(주인공.style.left),
      y: parseInt(주인공.style.top),
      deg: 0
    };
  }
  function 적군생성(num) {
    for (let i = 0; i < num; i++) {
      적카운터++;
      const 적군 = document.createElement('div');
      적군.classList.add('enemy');
      적군.id = `enemy${적카운터}`;
      HTML('#world').appendChild(적군);

      // 랜덤 위치 설정
      const randomX = Math.floor(Math.random() * 설정객체.월드크기.x);
      const randomY = Math.floor(Math.random() * 설정객체.월드크기.y);

      적군.style.top = `${randomY}px`;
      적군.style.left = `${randomX}px`;

      // 오브젝트에 적군 정보 저장
      오브젝트[`#enemy${적카운터}`] = {
        name: `#enemy${적카운터}`,
        x: randomX,
        y: randomY,
        deg: Math.floor(Math.random() * 180) + 1  // 1 ~ 180 사이의 각도 설정
      };
    }
  }

  
  function 이동(name, dx, dy) {
    const 요소 = document.querySelector(name);
    if (!요소) return;
    const currentX = parseFloat(요소.style.left || 0);
    const currentY = parseFloat(요소.style.top || 0);
    const newX = Math.max(0, Math.min(HTML('#world').offsetWidth - 요소.offsetWidth, currentX + dx));
    const newY = Math.max(0, Math.min(HTML('#world').offsetHeight - 요소.offsetHeight, currentY + dy));

    요소.style.left = `${newX}px`;
    요소.style.top = `${newY}px`;

    if (오브젝트[name]) {
      오브젝트[name].x = newX;
      오브젝트[name].y = newY;
    }
  }
  async function 적군거리계산() {
    if (충돌중복방지) {
      const player = HTML('#player');
      const playerRect = player.getBoundingClientRect();

      // 모든 적군에 대해 각각 충돌 여부를 검사
      const 적군들 = document.querySelectorAll('.enemy');
      for (let 적군 of 적군들) {
        const enemyRect = 적군.getBoundingClientRect();

        // 두 요소의 충돌 여부를 검사 (사각형 기준)
        const overlap = !(
          playerRect.right < enemyRect.left ||
          playerRect.left > enemyRect.right ||
          playerRect.bottom < enemyRect.top ||
          playerRect.top > enemyRect.bottom
        );

        if (overlap) {
          충돌중복방지 = false;
          const 적군Id = 적군.id;
          const 적군오브젝트 = 오브젝트[`#${적군Id}`];
          적군오브젝트.deg = (적군오브젝트.deg + 180) % 360; // 180도 반전

          // 적군 이동 방향 튕기게 하기
          const 이동거리 = Math.random() * 20 + 50;
          await 방향이동(적군Id, 적군오브젝트.deg, 이동거리);

          // 충돌 시 알림
          HTML('#player').style.filter = 'brightness(1.1) contrast(1.5)';
          // 충돌 처리 후 잠시 대기 후 중복 방지 다시 활성화
          setTimeout(() => {
            충돌중복방지 = true;
            HTML('#player').style.filter = '';
          }, 500); // 500ms 후에 중복 방지 활성화
          break; // 한 번 충돌하면 더 이상 체크하지 않도록
        }
      }
    }
  }


  document.addEventListener('keydown', (e) => {
    if (!keyIntervals[e.key]) {
      if (e.key === 'a') {
        keyIntervals[e.key] = setInterval(() => {
          이동('#player', -40, 0);
        }, 250);
      } else if (e.key === 'd') {
        keyIntervals[e.key] = setInterval(() => {
          이동('#player', 40, 0);
        }, 250);
      } else if (e.key === 'w') {
        keyIntervals[e.key] = setInterval(() => {
          이동('#player', 0, -40);
        }, 250);
      } else if (e.key === 's') {
        keyIntervals[e.key] = setInterval(() => {
          이동('#player', 0, 40);
        }, 250);
      }
    }
  });

  document.addEventListener('keyup', (e) => {
    // 키가 떼어지면 interval을 멈추도록
    if (keyIntervals[e.key]) {
      setTimeout(()=>{
        clearInterval(keyIntervals[e.key]);
        delete keyIntervals[e.key];
      },250);
    }
  });


  function 적군이동() {
    const player = HTML('#player');
    const playerRect = player.getBoundingClientRect();
    const playerX = playerRect.left + playerRect.width / 2;
    const playerY = playerRect.top + playerRect.height / 2;

    for (const key in 오브젝트) {
      const 대상오브젝트 = 오브젝트[key];
      if (!대상오브젝트.name.includes('player')) {
        // 플레이어와의 방향을 계산 (플레이어를 향해 이동하도록)
        const 적군 = HTML(대상오브젝트.name);
        const 적군Rect = 적군.getBoundingClientRect();
        const 적군X = 적군Rect.left + 적군Rect.width / 2;
        const 적군Y = 적군Rect.top + 적군Rect.height / 2;
        if(Math.floor(Math.random() * 100) >96-레벨*3){
          const 플레이어방향 = Math.atan2(playerY - 적군Y, playerX - 적군X) * (180 / Math.PI);
          대상오브젝트.deg = 플레이어방향
        }
        else{대상오브젝트.deg += Math.random() * 5.5; }
        // 이동 범위 및 이동 방향 결정
        const 이동거리 = Math.random() * 20 + 22 + 레벨*2;
        // 각도를 거리로 변환
        let 이동X = 이동거리 * Math.cos(대상오브젝트.deg * (Math.PI / 180));
        let 이동Y = 이동거리 * Math.sin(대상오브젝트.deg * (Math.PI / 180));

        const 월드 = HTML('#world');
        const 월드Rect = 월드.getBoundingClientRect();

        // 충돌 미리 계산 -> 피하기
        const 예상X = 적군Rect.left + 이동X;
        const 예상Y = 적군Rect.top + 이동Y;

        // 벽에 부딪히지 않도록 범위 내로 이동할 수 있는지 확인한 판단값 -> 가능하다면 반전
        const 벽충돌X = 예상X < 월드Rect.left || 예상X + 적군Rect.width > 월드Rect.right;
        const 벽충돌Y = 예상Y < 월드Rect.top || 예상Y + 적군Rect.height > 월드Rect.bottom;

        if (벽충돌X) {
          대상오브젝트.deg = 180 - 대상오브젝트.deg;
          이동X = -이동X;
        }
        if (벽충돌Y) {
          대상오브젝트.deg = 360 - 대상오브젝트.deg;
          이동Y = -이동Y;
        }

        // 이동방향
        이동(대상오브젝트.name, 이동X, 이동Y);
        // 회전 효과를 부드럽게 설정
        HTML(대상오브젝트.name).style.transition = 'all 2s linear, transform 1s ease';
        HTML(대상오브젝트.name).style.transform = `rotate(${대상오브젝트.deg + 90}deg)`;
      }
    }
  }

  let 적카운터=0;
  function 방향이동(name, deg, px) { //혹시나 몰라서 만듦
    const radian = deg * (Math.PI / 180);
    const 이동X = px * Math.cos(radian);
    const 이동Y = px * Math.sin(radian);

    if (오브젝트[name]) {
      이동(name, 이동X, 이동Y);
    }
  }

  let 레벨 = 1;
  async function 시작(){
    기본설정();
    await setTimeout(()=>{
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          // 기존 오브젝트 제거
          //for (const key in 오브젝트) {
          //  HTML(오브젝트[key].이름).remove();
          //  delete 오브젝트[key];
          //}
          //console.log('디버그');
          HTML('#score').innerHTML = '#' + 레벨;
          HTML('#score').style.animation = 'scoreSet 0.5s ease';  
          setTimeout(() => {
            HTML('#score').style.animation = ''; 
          }, 500);  
          적군생성(5+레벨);
          레벨++;

          // 웨이브 시작
          const 웨이브 = setInterval(() => {
            적군이동();
            적군거리계산();
          }, 150);

          // 60초 후 웨이브 종료
          setTimeout(() => { clearInterval(웨이브); }, 5000);
        }, i * 5000); // 각 레벨마다 60초 간격으로 시작
      }
    },100)
  }

  시작();


</script>
